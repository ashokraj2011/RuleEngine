package org.example;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.databind.node.ArrayNode;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

public class RuleEngine {

    private final ObjectMapper objectMapper = new ObjectMapper();
    private final Map<String, String> dataTypeMap = new HashMap<>();
    private final List<String> missingAttributesLog = new ArrayList<>();

    public RuleEngine(String dataTypeFilePath) throws IOException {
        loadDataTypes(dataTypeFilePath);
    }

    public void loadDataTypes(String filePath) throws IOException {
        if (filePath.endsWith(".json")) {
            JsonNode rootNode = objectMapper.readTree(new File(filePath));
            parseJsonNode(rootNode);
        } else {
            List<String> lines = Files.readAllLines(Paths.get(filePath));
            for (String line : lines) {
                String[] parts = line.split(":");
                if (parts.length == 2) {
                    String key = parts[0].trim();
                    String dataType = parts[1].trim();
                    dataTypeMap.put(key, dataType);
                }
            }
        }
    }

    private void parseJsonNode(JsonNode rootNode) {
        if (rootNode.isArray()) {
            for (JsonNode node : rootNode) {
                parseJsonNode(node);
            }
        } else if (rootNode.isObject()) {
            String datasource = rootNode.path("dataSourceName").asText();
            JsonNode registeredAttributes = rootNode.path("registeredAttributes");

            for (JsonNode attributeGroup : registeredAttributes) {
                String namespace = attributeGroup.path("namespace").asText();
                processAttributes(datasource, namespace, attributeGroup);
            }
        }
    }

    private void processAttributes(String datasource, String namespace, JsonNode attributeGroup) {
        JsonNode propertyGroups = attributeGroup.path("propertygroups");
        JsonNode attributeList = attributeGroup.path("attributeList");

        if (propertyGroups.isArray() && !propertyGroups.isEmpty()) {
            for (JsonNode propertyGroup : propertyGroups) {
                String propertyGroupName = propertyGroup.path("name").asText();
                JsonNode attributeListInGroup = propertyGroup.path("attributelist");

                if (attributeListInGroup.isArray()) {
                    for (JsonNode attribute : attributeListInGroup) {
                        addDataTypeMapping(datasource, namespace, propertyGroupName, attribute);
                    }
                }
            }
        }

        if (attributeList.isArray() && !attributeList.isEmpty()) {
            for (JsonNode attribute : attributeList) {
                addDataTypeMapping(datasource, namespace, null, attribute);
            }
        }
    }

    private void addDataTypeMapping(String datasource, String namespace, String propertyGroupName, JsonNode attribute) {
        String attributeName = attribute.path("attributeName").asText();
        String dataType = attribute.path("dataType").asText();
        String jsonPath = attribute.path("JsonPath").asText();

        String fullPath = "datasource:" + datasource + "," + namespace;
        if (propertyGroupName != null) {
            fullPath += "." + propertyGroupName;
        }
        fullPath += "." + attributeName;

        String mappingValue = dataType + ",jsonPath:" + jsonPath;
        dataTypeMap.put(fullPath, mappingValue);
    }

    public boolean evaluateRule(JsonNode mainData, JsonNode rule) {
        missingAttributesLog.clear();
        String operator = rule.path("op").asText();
        JsonNode terms = rule.path("terms");

        boolean result = operator.equalsIgnoreCase("and");

        for (JsonNode term : terms) {
            if (term.has("op")) {
                boolean nestedResult = evaluateRule(mainData, term);
                if (operator.equalsIgnoreCase("and") && !nestedResult) return false;
                if (operator.equalsIgnoreCase("or") && nestedResult) return true;
            } else {
                boolean conditionResult = evaluateCondition(mainData, term);
                if (operator.equalsIgnoreCase("and") && !conditionResult) return false;
                if (operator.equalsIgnoreCase("or") && conditionResult) return true;
            }
        }
        return result;
    }

    private boolean evaluateCondition(JsonNode mainData, JsonNode condition) {
        String datasource = condition.path("field").path("datasource").asText();
        String namespace = condition.path("field").path("namespace").asText();
        String fieldName = condition.path("field").path("name").asText();
        String comparison = condition.path("comp").asText();
        String value = condition.path("value").asText();

        String fullPath = "datasource:" + datasource + "," + namespace + "." + fieldName;
        String dataType = dataTypeMap.getOrDefault(fullPath, "String");

        JsonNode targetNode = mainData.at(parseJsonPath(namespace));
        if (targetNode.isMissingNode()) {
            logMissingAttribute(datasource, namespace, fieldName);
            return false;
        }

        boolean isValid = compareValues(targetNode.get(fieldName), value, comparison, dataType);
        if (!isValid) {
            logInvalidType(fieldName, targetNode.get(fieldName).getNodeType().toString(), dataType);
        }
        return isValid;
    }

    private String parseJsonPath(String namespace) {
        return "/" + namespace.replaceAll("\\.", "/");
    }

    private void logMissingAttribute(String datasource, String namespace, String fieldName) {
        missingAttributesLog.add("Missing attribute: " + datasource + ", " + namespace + "." + fieldName);
    }

    private void logInvalidType(String fieldName, String foundType, String expectedType) {
        missingAttributesLog.add("Type Mismatch: Field '" + fieldName + "' expected type '" + expectedType + "' but found '" + foundType + "'.");
    }

    public void printMissingAttributesLog() {
        if (!missingAttributesLog.isEmpty()) {
            System.out.println("\nMissing Attributes Log:");
            missingAttributesLog.forEach(System.out::println);
        }
    }
}


-----second version
package org.example;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.databind.node.ArrayNode;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

public class RuleEngine {

    private final ObjectMapper objectMapper = new ObjectMapper();
    private final Map<String, String> dataTypeMap = new HashMap<>();
    private final List<String> missingAttributesLog = new ArrayList<>();

    public RuleEngine(String dataTypeFilePath) throws IOException {
        loadDataTypes(dataTypeFilePath);
    }

    public void loadDataTypes(String filePath) throws IOException {
        if (filePath.endsWith(".json")) {
            JsonNode rootNode = objectMapper.readTree(new File(filePath));
            parseJsonNode(rootNode);
        } else {
            List<String> lines = Files.readAllLines(Paths.get(filePath));
            for (String line : lines) {
                String[] parts = line.split(":");
                if (parts.length == 2) {
                    String key = parts[0].trim();
                    String dataType = parts[1].trim();
                    dataTypeMap.put(key, dataType);
                }
            }
        }
    }

    private void parseJsonNode(JsonNode rootNode) {
        if (rootNode.isArray()) {
            for (JsonNode node : rootNode) {
                parseJsonNode(node);
            }
        } else if (rootNode.isObject()) {
            String datasource = rootNode.path("dataSourceName").asText();
            JsonNode registeredAttributes = rootNode.path("registeredAttributes");

            for (JsonNode attributeGroup : registeredAttributes) {
                String namespace = attributeGroup.path("namespace").asText();
                processAttributes(datasource, namespace, attributeGroup);
            }
        }
    }

    private void processAttributes(String datasource, String namespace, JsonNode attributeGroup) {
        JsonNode propertyGroups = attributeGroup.path("propertygroups");
        JsonNode attributeList = attributeGroup.path("attributeList");

        if (propertyGroups.isArray() && !propertyGroups.isEmpty()) {
            for (JsonNode propertyGroup : propertyGroups) {
                String propertyGroupName = propertyGroup.path("name").asText();
                JsonNode attributeListInGroup = propertyGroup.path("attributelist");

                if (attributeListInGroup.isArray()) {
                    for (JsonNode attribute : attributeListInGroup) {
                        addDataTypeMapping(datasource, namespace, propertyGroupName, attribute);
                    }
                }
            }
        }

        if (attributeList.isArray() && !attributeList.isEmpty()) {
            for (JsonNode attribute : attributeList) {
                addDataTypeMapping(datasource, namespace, null, attribute);
            }
        }
    }

    private void addDataTypeMapping(String datasource, String namespace, String propertyGroupName, JsonNode attribute) {
        String attributeName = attribute.path("attributeName").asText();
        String dataType = attribute.path("dataType").asText();
        String jsonPath = attribute.path("JsonPath").asText();

        String fullPath = "datasource:" + datasource + "," + namespace;
        if (propertyGroupName != null) {
            fullPath += "." + propertyGroupName;
        }
        fullPath += "." + attributeName;

        String mappingValue = dataType + ",jsonPath:" + jsonPath;
        dataTypeMap.put(fullPath, mappingValue);
    }

    private boolean compareValues(JsonNode targetNode, String value, String comparison, String dataType) {
        try {
            switch (comparison.toLowerCase()) {
                case "equal to":
                    return targetNode.asText().equals(value);
                case "greater than":
                    return Double.compare(targetNode.asDouble(), Double.parseDouble(value)) > 0;
                case "less than":
                    return Double.compare(targetNode.asDouble(), Double.parseDouble(value)) < 0;
                case "contains":
                    return targetNode.asText().contains(value);
                case "starts with":
                    return targetNode.asText().startsWith(value);
                case "ends with":
                    return targetNode.asText().endsWith(value);
                case "not equal to":
                    return !targetNode.asText().equals(value);
                case "greater than or equal to":
                    return Double.compare(targetNode.asDouble(), Double.parseDouble(value)) >= 0;
                case "less than or equal to":
                    return Double.compare(targetNode.asDouble(), Double.parseDouble(value)) <= 0;
                default:
                    return false;
            }
        } catch (Exception e) {
            logInvalidType(targetNode.toString(), dataType);
            return false;
        }
    }

    private String parseJsonPath(String namespace) {
        return "/" + namespace.replaceAll("\\.", "/");
    }

    private void logMissingAttribute(String datasource, String namespace, String fieldName) {
        missingAttributesLog.add("Missing attribute: " + datasource + ", " + namespace + "." + fieldName);
    }

    private void logInvalidType(String fieldValue, String expectedType) {
        missingAttributesLog.add("Type Mismatch: Expected type '" + expectedType + "' but found value '" + fieldValue + "'.");
    }

    public void printMissingAttributesLog() {
        if (!missingAttributesLog.isEmpty()) {
            System.out.println("\nMissing Attributes Log:");
            missingAttributesLog.forEach(System.out::println);
        }
    }
}
-----
date
package org.example;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.databind.node.ArrayNode;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

public class RuleEngine {

    private final ObjectMapper objectMapper = new ObjectMapper();
    private final Map<String, String> dataTypeMap = new HashMap<>();
    private final List<String> missingAttributesLog = new ArrayList<>();

    public RuleEngine(String dataTypeFilePath) throws IOException {
        loadDataTypes(dataTypeFilePath);
    }

    public void loadDataTypes(String filePath) throws IOException {
        if (filePath.endsWith(".json")) {
            JsonNode rootNode = objectMapper.readTree(new File(filePath));
            parseJsonNode(rootNode);
        } else {
            List<String> lines = Files.readAllLines(Paths.get(filePath));
            for (String line : lines) {
                String[] parts = line.split(":");
                if (parts.length == 2) {
                    String key = parts[0].trim();
                    String dataType = parts[1].trim();
                    dataTypeMap.put(key, dataType);
                }
            }
        }
    }

    private void parseJsonNode(JsonNode rootNode) {
        if (rootNode.isArray()) {
            for (JsonNode node : rootNode) {
                parseJsonNode(node);
            }
        } else if (rootNode.isObject()) {
            String datasource = rootNode.path("dataSourceName").asText();
            JsonNode registeredAttributes = rootNode.path("registeredAttributes");

            for (JsonNode attributeGroup : registeredAttributes) {
                String namespace = attributeGroup.path("namespace").asText();
                processAttributes(datasource, namespace, attributeGroup);
            }
        }
    }

    private void processAttributes(String datasource, String namespace, JsonNode attributeGroup) {
        JsonNode propertyGroups = attributeGroup.path("propertygroups");
        JsonNode attributeList = attributeGroup.path("attributeList");

        if (propertyGroups.isArray() && !propertyGroups.isEmpty()) {
            for (JsonNode propertyGroup : propertyGroups) {
                String propertyGroupName = propertyGroup.path("name").asText();
                JsonNode attributeListInGroup = propertyGroup.path("attributelist");

                if (attributeListInGroup.isArray()) {
                    for (JsonNode attribute : attributeListInGroup) {
                        addDataTypeMapping(datasource, namespace, propertyGroupName, attribute);
                    }
                }
            }
        }

        if (attributeList.isArray() && !attributeList.isEmpty()) {
            for (JsonNode attribute : attributeList) {
                addDataTypeMapping(datasource, namespace, null, attribute);
            }
        }
    }

    private void addDataTypeMapping(String datasource, String namespace, String propertyGroupName, JsonNode attribute) {
        String attributeName = attribute.path("attributeName").asText();
        String dataType = attribute.path("dataType").asText();
        String jsonPath = attribute.path("JsonPath").asText();

        String fullPath = "datasource:" + datasource + "," + namespace;
        if (propertyGroupName != null) {
            fullPath += "." + propertyGroupName;
        }
        fullPath += "." + attributeName;

        String mappingValue = dataType + ",jsonPath:" + jsonPath;
        dataTypeMap.put(fullPath, mappingValue);
    }

    private LocalDateTime parseDateTimeValue(String value) {
        LocalDateTime currentDate = LocalDateTime.now();
        if (value.startsWith("CURRENT_DATE:")) {
            String[] parts = value.split(":");
            String operation = parts[2].toLowerCase();
            int amount = Integer.parseInt(parts[3].split("\(")[0].trim());
            String unit = parts[3].split("\(")[1].replace(")", "").trim();

            switch (unit) {
                case "day(s)":
                    return operation.equals("from now") ? currentDate.plusDays(amount) : currentDate.minusDays(amount);
                case "month(s)":
                    return operation.equals("from now") ? currentDate.plusMonths(amount) : currentDate.minusMonths(amount);
                case "year(s)":
                    return operation.equals("from now") ? currentDate.plusYears(amount) : currentDate.minusYears(amount);
                default:
                    return currentDate;
            }
        }
        return LocalDateTime.parse(value, DateTimeFormatter.ISO_DATE_TIME);
    }

    private <T extends Comparable<T>> boolean evaluateComparison(T targetValue, T comparisonValue, String comparison) {
        return switch (comparison.toLowerCase()) {
            case "equal to" -> targetValue.compareTo(comparisonValue) == 0;
            case "greater than" -> targetValue.compareTo(comparisonValue) > 0;
            case "less than" -> targetValue.compareTo(comparisonValue) < 0;
            case "greater than or equal to" -> targetValue.compareTo(comparisonValue) >= 0;
            case "less than or equal to" -> targetValue.compareTo(comparisonValue) <= 0;
            default -> false;
        };
    }
}
------


private boolean compareValues(JsonNode targetNode, String value, String comparison, String dataType) {
        if (targetNode == null || targetNode.isMissingNode()) {
            if (comparison.equalsIgnoreCase("exists")) return false;
            if (comparison.equalsIgnoreCase("not exists")) return true;
            if (comparison.equalsIgnoreCase("is null")) return true;
            if (comparison.equalsIgnoreCase("is empty")) return true;
            return false;
        }

        if (comparison.equalsIgnoreCase("exists")) return true;
        if (comparison.equalsIgnoreCase("not exists")) return false;
        if (comparison.equalsIgnoreCase("is null")) return targetNode.isNull();
        if (comparison.equalsIgnoreCase("is empty")) {
            if (targetNode.isTextual()) return targetNode.asText().isEmpty();
            if (targetNode.isArray()) return targetNode.size() == 0;
            if (targetNode.isObject()) return targetNode.size() == 0;
        }

        if (targetNode.isArray() || targetNode.isObject()) {
            List<String> values = new ArrayList<>();
            if (targetNode.isArray()) {
                for (JsonNode element : targetNode) {
                    values.add(element.asText());
                }
            } else if (targetNode.isObject()) {
                targetNode.fieldNames().forEachRemaining(field -> values.add(targetNode.get(field).asText()));
            }

            if (comparison.equalsIgnoreCase("exists")) {
                return values.contains(value);
            } else if (comparison.equalsIgnoreCase("not exists")) {
                return !values.contains(value);
            }
        }

        try {
            if (dataType.equalsIgnoreCase("DateTime")) {
                LocalDateTime targetDate = LocalDateTime.parse(targetNode.asText(), DateTimeFormatter.ISO_DATE_TIME);
                LocalDateTime comparisonDate = parseDateTimeValue(value);
                return evaluateComparison(targetDate, comparisonDate, comparison);
            }
            switch (comparison.toLowerCase()) {
                case "equal to":
                    return targetNode.asText().equals(value);
                case "greater than":
                    return Double.compare(targetNode.asDouble(), Double.parseDouble(value)) > 0;
                case "less than":
                    return Double.compare(targetNode.asDouble(), Double.parseDouble(value)) < 0;
                case "greater than or equal to":
                    return Double.compare(targetNode.asDouble(), Double.parseDouble(value)) >= 0;
                case "less than or equal to":
                    return Double.compare(targetNode.asDouble(), Double.parseDouble(value)) <= 0;
                default:
                    return false;
            }
        } catch (Exception e) {
            return false;
        }
    }




------apr
    private boolean compareValues(JsonNode targetNode, String value, String comparison, String dataType) {
        if (targetNode == null || targetNode.isMissingNode()) {
            if (comparison.equalsIgnoreCase("exists")) return false;
            if (comparison.equalsIgnoreCase("not exists")) return true;
            if (comparison.equalsIgnoreCase("is null")) return true;
            if (comparison.equalsIgnoreCase("is empty")) return true;
            return false;
        }

        if (comparison.equalsIgnoreCase("exists")) return true;
        if (comparison.equalsIgnoreCase("not exists")) return false;
        if (comparison.equalsIgnoreCase("is null")) return targetNode.isNull();
        if (comparison.equalsIgnoreCase("is empty")) {
            if (targetNode.isTextual()) return targetNode.asText().isEmpty();
            if (targetNode.isArray()) return targetNode.size() == 0;
            if (targetNode.isObject()) return targetNode.size() == 0;
        }

        if (targetNode.isArray()) {
            for (JsonNode element : targetNode) {
                if (compareValues(element, value, comparison, dataType)) {
                    return true;
                }
            }
            return false;
        }

        if (targetNode.isObject() && targetNode.has(value)) {
            targetNode = targetNode.get(value); // Drilling down nested objects
        }

        try {
            if (dataType.equalsIgnoreCase("DateTime")) {
                LocalDateTime targetDate = LocalDateTime.parse(targetNode.asText(), DateTimeFormatter.ISO_DATE_TIME);
                LocalDateTime comparisonDate = parseDateTimeValue(value);
                return evaluateComparison(targetDate, comparisonDate, comparison);
            }
            switch (comparison.toLowerCase()) {
                case "equal to":
                    return targetNode.asText().equals(value);
                case "greater than":
                    return Double.compare(targetNode.asDouble(), Double.parseDouble(value)) > 0;
                case "less than":
                    return Double.compare(targetNode.asDouble(), Double.parseDouble(value)) < 0;
                case "greater than or equal to":
                    return Double.compare(targetNode.asDouble(), Double.parseDouble(value)) >= 0;
                case "less than or equal to":
                    return Double.compare(targetNode.asDouble(), Double.parseDouble(value)) <= 0;
                default:
                    return false;
            }
        } catch (Exception e) {
            return false;
        }
    }



----

        String fullPath = "datasource:" + datasource + "," + namespace + "." + fieldName;
        String dataTypeMapping = dataTypeMap.get(fullPath);

        if (dataTypeMapping == null) {
            missingAttributesLog.add("Missing attribute: " + fullPath);
            return false;
        }

        String[] parts = dataTypeMapping.split(",jsonPath:");
        String dataType = parts[0];
        String jsonPath = parts.length > 1 ? parts[1] : "";